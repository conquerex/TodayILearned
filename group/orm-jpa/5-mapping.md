# 5장. 연관관계 매핑 기초

## 입구

* <mark style="color:red;">**객체는 참조(주소)**</mark>**를 사용해서 관계를 맺고**
* <mark style="color:red;">**테이블은 외래키**</mark>**를 사용해서 관계를 맺는다**
* 객체 관계 매핑(ORM)에서 가장 어려운 부분 > 객체 연관관계와 테이블 연관관계를 매핑하는 일
* 방향
  * 단방향, 양방향
* 다중성
  * 다대일, 일대다, 일대일, 일대다
* 연관관계의 주인
  * 양방향 연관관계로 만들면 연관관계의 주인을 정해야



## 5.1 단방향 연관관계

* 회원과 팀
* 객체 연관관계
  * 회원 객체는 Member.team 필드(멤버변수)로 팀 객체와 연관관계를 맺는다
  * 단방향 : 회원을 통해 팀을 알수 있지만 팀은 회원을 알 수 없다.
  * 예) member.getTeam()
* 테이블 연관관계
  * 회원 테이블은 TEAM_ID 외래키로 팀 테이블과 연관관계를 맺는다
  * 양방향 : 회원 테이블의 TEAM_ID 외래키를 통해서 회원과 팀을 조인할 수 있다
  * 예) MEMBER JOIN TEAM, TEAM JOIN MEMBER

```
SELECT *
FROM MEMBER M
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID

SELECT *
FROM TEAM T
JOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID
```

* 객체 연관관계와 테이블 연관관계의 가장 큰 차이
  * 참조를 통한 연관관계는 언제나 단방향
  * 양방향 관계 : 정확히는 서로 다른 단방향 관계 2개

샘플 코드

* 객체 그래프 탐색 : 객체는 참조를 사용해서 연관관계를 탐색
* 조인 : 데이터베이스는 외래키를 사용해서 연관관계를 탐색

팀과 멤버의 매핑

* 객체 연관관계 : 회원 객체의 Member.team 필드 사용
* 테이블 연관관계 : 회원 테이블의 MEMBER.TEAM_ID 외래키 컬럼을 사용
* @ManyToOne
  * 다대일 관계라는 매핑 정보 (회원:팀)
  * 연관관계를 매핑할 때 다중성을 나타내는 어노테이션을 필수로 사용해야
  * 속성 관련해서는 8장에서 자세히 다룸
  * targetEntity 속성 : 제네릭이 없을 때 타입정보를 알게 해줌
* @JoinColumn(name="TEAM_ID")
  * 조인 컬럼은 외래키를 매핑할 때 사용
  * name 속성에는 매핑할 외래 키(TEAM_ID) 이름을 지정
  * referencedColumnName을 포함한 여러개의 속성과
  * @Column이 가지는 제약조건성 속성들을 가지고 있다.
  * 생략시 기본값 세팅
    * 궁금증 : 필드명 + 밑줄 + 참조하는 테이블의 컬럼명(이건 어떻게 알 수 있나?? 이걸 세팅하기 위한 JoinColumn이 아닌가?)



## 5.2 연관관계 사용

* 저장
  * JPA는 참조한 팀의 식별자(Team.id)를 외래키로 사용해서 적절한 등록 쿼리를 생성
* 조회
  * 객체 그래프 탐색 (객체 연관관계를 사용한 조회)
  * 객체지향 쿼리 사용, JPQL (상세한 내용은 10장에서)
* 수정
  * em.update() 같은 거 없다
  * 불러온 엔티티의 값만 변경해두면 - 트랜잭션을 커밋할 때 - 플러시가 일어나면서 - 변경 감지 기능이 작동
  * 그리고 변경사항을 데이터베이스에 자동으로 반영
* 연관관계 제거
  * 연관관계를 null로 설정
* 연관된 엔티티 삭제
  * 기존에 있던 연관관계를 먼저 제거하고 삭제
  * 만약 이 순서로 안한다면??



## 5.3 양방향 연관관계

* 회원과 팀 - 다대일 관계 (Member.team)
* 팀에서 회원 - 일대다 관계 (Team.members)
   * 여러 건과 연관관계를 맺을 수 있으므로 컬렉션을 사용해야
   * 컬렉션과 관련된 내용은 14장에서 자세히...
* 데이터베이스는 외래키 하나로 양방향 쌉가능
   * 별도로 추가할 사항이 없다
* 단방향 연관관계 매핑과 비교했을 때...
  * 회원 엔티티 - 변경사항 없음
  * 팀 엔티티 - @OneToMany 추가
* 일대다 관계를 매핑하기 위해
  * @OneToMany 매핑 정보를 사용
  * mappedBy 속성 : 양방향 매핑일 때 사용. 반대쪽 매핑의 필드 이름을 값으로 주면 됨


## 5.4 연관관계의 주인

* 테이블은 외래키 하나로 2개의 테이블의 연관관계를 관리
* 하지만 엔티티를 양방향으로 매핑하면 2곳에서 서로를 참조한다
  * 외래키는 한개인데. 이 둘의 차이가 발생
* 연관관계의 주인
  * JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리
* 두 연관관계 중 하나를 연관관계의 주인(이하 줄여서 주인)으로 정해야
  * 주인만이 데이터베이스 연관관계와 매핑되고 외래키를 관리(등록, 수정, 삭제)
  * 주인이 아닌 쪽은 읽기만
* 주인
  * mappedBy 속성을 사용하지 않음
* 주인이 아닌 쪽
  * mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정
* 연관관계의 주인을 정한다는 것 = 외래키 관리자를 선택하는 것
  * TEAM_ID 외래키를 관리할 관리자를 선택
  * Member.team을 주인으로 선택하면 자기 테이블에 있는 외래키르 관리하면 됨
  * 궁금 : 팀 엔티티에 있는 members를 주인으로 선택하면 물리적으로 전혀 다른 테이블의 외래키를 관리해야 한다??
* 연관관계의 주인 = 외래키가 있는 곳
  * mappedBy 속성 값 : 연관관계의 주인인 team
    * Member 엔티티의 team 필드
  * 궁금 : 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래키를 가진다
    * 다 쪽인 ManyToOne은 항상 연관관계의 주인
    * mappedBy를 설정할 수 없다
    * 따라서 ManyToOne에는 mappedBy 속성이 없다
    * (사견) OneToMany가 주인 역할을 못하는 것은 오히려 mappedBy가 없어서가 아닌가? 원인과 결과가 바뀐 느낌


## 5.5 양방향 연관관계 저장

* 단방향과 저장하는 방식은 동일
* 주인이 아닌 방향은 값을 설정하지 않아도 데이터베이스에 외래키 값이 정상 입력됨
* 주인이 아닌 곳에 입력된 값은 외래키에 영향을 주지 않는다



## 5.6 양방향 연관관계의 주의점

* 주요 실수
  * 주인에는 값을 입력하지 않고
  * 주인이 아닌 곳에만 값을 입력
* 객체 관정에서 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전
  * 순수한 객체 연관관계에서는 한쪽 방향만 저장했을 때
    * 반대쪽에서 조회를 하면 원하는 결과가 나오지 않음
  * 이런 결과를 원하지 않는다면 양쪽 모두 관계를 설정해야 함
    * 순수한 객체 상태에서도, 테이블의 외래키에서도 정상 입력 및 동장이 된다
  * (사견) 기본적으로 객체는 믿지 않는다는 관점으로 개발해야 하지 않을까? 트래픽 비용이 부담되지 않는다면 데이터 필요할 때마다 조회하는게 안전하지 않을까
* 양방향 저장을 한 메소드에서 수행할 수 있도록 리팩토링을 권장
  * 편의 메소드 : 한 번에 양방향 관계를 설정하는 메소드
* 연관관계 편의 메소드 작성 시 주의사항
  * 예) 멤버에 team1을 저장한 후 team2로 변경했을 때
    * team1 -> member 관계는 제거되어 있지 않음
    * 물론 DB상에서는 문제없음
    * (사견) 그래서 위 내용을 언급한 것. 객체를 믿지 말자는 것. 영속성 컨텍스트가 아직 살아있는 상태를 전제에서 제외하면 안될까 (도서의 참조 내용)
  * 편의 메소드에서 기존 관계를 제거하는 코드를 포함해야



## 5.7 정리

* 양방향의 장점
  * 반대방향으로 객체 그래프 탐색 기능이 추가된 것뿐
* 우선 단방향 매핑을 사용하고 반대방향으로 객체 그래프 탐색 기능이 필요할 때 양방향을 사용하도록 코드를 추가해도...
  * 궁금 : 구현 난이도를 떠나서 단방향과 양방향에서 시간/트래픽 등의 비용 차이가 있는가? 미리 양방향으로 모두 구성하면 안되는 이유가 있는가?
* 주인을 정하는 기준과 비즈니스의 중요도는 전혀 관계가 없다.
* 양방향 매핑 시 무한 루프에 주의
  * 궁금 : 해결방법 뒤에서 나오나?
* 일대다를 주인으로 선택 가능 but 성능과 관리 측면에서 권장하지 않음
  * 6장에서 자세히 다룸

<br>

![](../../group/orm-jpa/image/5-end.png)
