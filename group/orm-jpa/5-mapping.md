# 5장. 연관관계 매핑 기초

## 입구

* <mark style="color:red;">**객체는 참조(주소)**</mark>**를 사용해서 관계를 맺고**
* <mark style="color:red;">**테이블은 외래키**</mark>**를 사용해서 관계를 맺는다**
* 객체 관계 매핑(ORM)에서 가장 어려운 부분 > 객체 연관관계와 테이블 연관관계를 매핑하는 일
* 방향
  * 단방향, 양방향
* 다중성
  * 다대일, 일대다, 일대일, 일대다
* 연관관계의 주인
  * 양방향 연관관계로 만들면 연관관계의 주인을 정해야



## 5.1 단방향 연관관계

* 회원과 팀
* 객체 연관관계
  * 회원 객체는 Member.team 필드(멤버변수)로 팀 객체와 연관관계를 맺는다
  * 단방향 : 회원을 통해 팀을 알수 있지만 팀은 회원을 알 수 없다.
  * 예) member.getTeam()
* 테이블 연관관계
  * 회원 테이블은 TEAM_ID 외래키로 팀 테이블과 연관관계를 맺는다
  * 양방향 : 회원 테이블의 TEAM_ID 외래키를 통해서 회원과 팀을 조인할 수 있다
  * 예) MEMBER JOIN TEAM, TEAM JOIN MEMBER

```
SELECT *
FROM MEMBER M
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID

SELECT *
FROM TEAM T
JOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID
```

* 객체 연관관계와 테이블 연관관계의 가장 큰 차이
  * 참조를 통한 연관관계는 언제나 단방향
  * 양방향 관계 : 정확히는 서로 다른 단방향 관계 2개

샘플 코드

* 객체 그래프 탐색 : 객체는 참조를 사용해서 연관관계를 탐색
* 조인 : 데이터베이스는 외래키를 사용해서 연관관계를 탐색

팀과 멤버의 매핑

* 객체 연관관계 : 회원 객체의 Member.team 필드 사용
* 테이블 연관관계 : 회원 테이블의 MEMBER.TEAM_ID 외래키 컬럼을 사용
* @ManyToOne
  * 다대일 관계라는 매핑 정보 (회원:팀)
  * 연관관계를 매핑할 때 다중성을 나타내는 어노테이션을 필수로 사용해야
  * 속성 관련해서는 8장에서 자세히 다룸
  * targetEntity 속성 : 제네릭이 없을 때 타입정보를 알게 해줌
* @JoinColumn(name="TEAM_ID")
  * 조인 컬럼은 외래키를 매핑할 때 사용
  * name 속성에는 매핑할 외래 키(TEAM_ID) 이름을 지정
  * referencedColumnName을 포함한 여러개의 속성과
  * @Column이 가지는 제약조건성 속성들을 가지고 있다.
  * 생략시 기본값 세팅
    * 궁금증 : 필드명 + 밑줄 + 참조하는 테이블의 컬럼명(이건 어떻게 알 수 있나?? 이걸 세팅하기 위한 JoinColumn이 아닌가?)



## 5.2 연관관계 사용

* 저장
  * JPA는 참조한 팀의 식별자(Team.id)를 외래키로 사용해서 적절한 등록 쿼리를 생성
* 조회
  * 객체 그래프 탐색 (객체 연관관계를 사용한 조회)
  * 객체지향 쿼리 사용, JPQL (상세한 내용은 10장에서)
* 수정
  * em.update() 같은 거 없다
  * 불러온 엔티티의 값만 변경해두면 - 트랜잭션을 커밋할 때 - 플러시가 일어나면서 - 변경 감지 기능이 작동
  * 그리고 변경사항을 데이터베이스에 자동으로 반영
* 연관관계 제거
  * 연관관계를 null로 설정
* 연관된 엔티티 삭제
  * 기존에 있던 연관관계를 먼저 제거하고 삭제
  * 만약 이 순서로 안한다면??



## 5.3 양방향 연관관계

* 회원과 팀 - 다대일 관계 (Member.team)
* 팀에서 회원 - 일대다 관계 (Team.members)
   * 여러 건과 연관관계를 맺을 수 있으므로 컬렉션을 사용해야
   * 컬렉션과 관련된 내용은 14장에서 자세히...
* 데이터베이스는 외래키 하나로 양방향 쌉가능
   * 별도로 추가할 사항이 없다
* 단방향 연관관계 매핑과 비교했을 때...
  * 회원 엔티티 - 변경사항 없음
  * 팀 엔티티 - @OneToMany 추가
* 일대다 관계를 매핑하기 위해
  * @OneToMany 매핑 정보를 사용
  * mappedBy 속성 : 양방향 매핑일 때 사용. 반대쪽 매핑의 필드 이름을 값으로 주면 됨


## 5.4 연관관계의 주인

* 테이블은 외래키 하나로 2개의 테이블의 연관관계를 관리
* 하지만 엔티티를 양방향으로 매핑하면 2곳에서 서로를 참조한다
  * 외래키는 한개인데. 이 둘의 차이가 발생
* 연관관계의 주인
  * JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리
* 두 연관관계 중 하나를 연관관계의 주인(이하 줄여서 주인)으로 정해야
  * 주인만이 데이터베이스 연관관계와 매핑되고 외래키를 관리(등록, 수정, 삭제)
  * 주인이 아닌 쪽은 읽기만
* 주인
  * mappedBy 속성을 사용하지 않음
* 주인이 아닌 쪽
  * mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정
* 연관관계의 주인을 정한다는 것 = 외래키 관리자를 선택하는 것
  * TEAM_ID 외래키를 관리할 관리자를 선택
  * Member.team을 주인으로 선택하면 자기 테이블에 있는 외래키르 관리하면 됨
  * 궁금 : 팀 엔티티에 있는 members를 주인으로 선택하면 물리적으로 전혀 다른 테이블의 외래키를 관리해야 한다??연관관계의 주인 = 외래키가 있는 곳mappedBy 속성 값 : 연관관계의 주인인 teamMember 엔티티의 team 필드궁금 : 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래키를 가진다다 쪽인 ManyToOne은 항상 연관관계의 주인mappedBy를 설정할 수 없다따라서 ManyToOne에는 mappedBy 속성이 없다(사견) OneToMany가 주인 역할을 못하는 것은 오히려 mappedBy가 없어서가 아닌가? 원인과 결과가 바뀐 느낌
