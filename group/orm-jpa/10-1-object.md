# 10장. 객체지향 쿼리 언어

## 입구

- JPA는 복잡한 검색 조건을 사용해서 엔티티 객체를 조회할 수 있는 다양한 쿼리 기술을 지원
- JPQL은 가장 중요한 객체지향 쿼리 언어
    - Criteria, QueryDSL은 결국 JPQL을 편리하게 사용하도록 도와주는 기술

## 1. 객체지향 쿼리 소개

- 가장 단순한 검색 방법
    - 식별자로 조회
        - EntityManager.find()
        - 이 메소드를 사용하면 식별자로 엔티티 하나를 조회할 수 있다
    - 객체 그래프 탐색
        - 예) a.getB()
        - 연관된 엔티티들을 찾을 수 있다
- ORM을 사용하면 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 개발하므로
    - 검색도 테이블이 아닌 엔티티 객체를 대상으로 하는 방법이 필요
- JPQL의 특징
    - 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리
    - SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다
- SQL이 데이터베이스 테이블을 대상으로 하는 데이터 중심의 쿼리라면
    - JPQL은 엔티티 객체를 대상으로 하는 **객체지향 쿼리**
- JPQL을 사용하면
    - JPA는 이 JPQL을 분석한 다음 적절한 SQL을 만들어 데이터베이스를 조회
    - 그리고 조회한 결과로 엔티티 객체를 생성해서 반환
- JPA가 공식 지원하는 기능
    - JPQL : Java Persistence Query Language
    - Criteria Query : JPQL을 편하게 작성하도록 도와주는 API, 빌더 클래스 모음
    - 네이티브 Query : JPA에서 JPQL 대신 직접 SQL을 사용할 수 있다
- JPA가 공식 지원하는 기능은 아니지만...
    - QueryDSL
        - 크리테리아 쿼리처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스 모음
        - 비표준 오픈소스 프레임워크
    - JDBC 직접 사용, MyBatis 같은 SQL 매퍼 프레임워크 사용
        - 필요하면 JDBC를 직접 사용할 수 있다
- JPQL
    - 엔티티 객체를 조회하는 객체지향 쿼리
    - 문법은 SQL과 유사
    - SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다
    - 데이터베이스 방언만 변경하면 JPQL을 수정하지 않아도 자연스럽게 데이터베이스를 변경할 수 있다.
    - SQL보다 간결하다
        - 엔티티 직접 조회, 묵시적 조인, 다형성 지원으로 간결
- 예) delect m from Member as m where m.username = 'kim'
    - m.username : 테이블 컬럼명이 아닌 엔티티 객체의 필드명
    - em.createQuery 메소드를 실행할 JPQL과
    - 반환할 엔티티의 클래스 타입인 Member.class를 넘겨주고
    - getResultList 메소드를 실행
    - JPA는 JPQL을 SQL로 변환해서 데이터베이스를 조회
    - 결과 : Member 엔티티를 생성해서 반환
- Criteria 쿼리
    - JPQL을 생성하는 빌더 클래스
    - 장점 : 문자가 아닌 query.select(m).where(...)처럼 프로그래밍 코드로 JPQL을 작성할 수 있다는 점
    - JPQL에서 오타가 있어도 컴파일은 성공하고 서버에 배포도 가능
        - 쿼리가 실행되는 런타임 시점에 오류가 발생
        - 문자 기반 쿼리의 단점
    - 그 외...
        - 컴파일 시점에 오류를 발견할 수 있다
        - IDE를 사용하면 코드 자동완성을 지원
        - 동적 쿼리를 작성하기 편하다
    - 몇몇 ORM 프레임워크들이 오래전부터 자신만의 크리테리아 지원
        - JPA 2.0부터
    - 필드명을 문자로 작성  → 해결 : 메타 모델
    - 단점
        - 모든 장점을 상쇄할 정도로 복잡 + 장황
        - 사용하기 불편, 작성한 코드도 한눈에 들어오지 않음
- QueryDSL
    - 크리테리아처럼 JPQL 빌더 역할
    - 장점
        - 코드 기반이면서 단순하고 사용하기 쉽다
        - 작성한 코드도 JPQL과 비슷해서 한눈에 들어온다
    - JPA 표준이 아님
        - 오픈소스 프로젝트
        - JDO, 몽고DB, Java Collection, Lucene, Hibernate Search도 거의 같은 문법으로 지원
        - 현재 스프링 데이터 프로젝트가 지원할 정도로 많이 기대되는 프로젝트
    - 어노테이션 프로세서를 사용해서 쿼리 전용 클래스를 만들어야 한다
- 네이티브 SQL
    - JPA는 SQL을 직접 사용할 수 있는 기능을 지원
    - 가끔 특정 데이터베이스에 의존하는 기능을 사용해야 할 때
    - SQL은 지원하지만 JPQL이 지원하지 않는 기능일 때
    - 단점
        - 특정 데이터베이스에 의존하는 SQL을 작성해야 한다는 것
        - 데이터베이스를 변경하면 네이티브 SQL도 수정해야
    - em.createNativeQuery()
- JDBC 직접 사용, 마이바티스같은 SQL 매퍼 프레임워크 사용
    - JPA는 JDBC 커넥션을 획득하는 API를 제공하지 않음
        - JPA 구현체가 제공하는 방법을 사용해야
    - JDBC나 마이바티스를 JPA와 함께 사용하면
        - 영속성 컨텍스트를 적절한 시점에 강제로 플러시해야 한다
    - 해당 이슈 해결 방법
      - JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트를 수동으로 플러시
      - 데이터베이스와 영속성 컨텍스트를 동기화

## 2. JPQL

- 특징을 다시
    - 객체지향 쿼리 언어 : 테이블을 대상으로 쿼리한느 것이 아니라 엔티티 객체를 대상으로 쿼리
    - SQL을 추상화 - 특정 데이터베이스 SQL에 의존하지 않는다
    - 결국 SQL로 변환된다
- JPQL insert문
    - 엔티티를 저장할 때 EntityManger.persist() 메소드를 사용하면 되므로 별도의 insert문은 없다
- select문
    - 엔티티와 속성은 대소문자 구분
    - 클래스명이 아니라 엔티티 이름
    - 별칭은 필수 (JPA 표준 명세에서는 별칭을 식별 변수라고 부른다)
- 하이버네이트
    - JPQL 표준도 지원하지만 더 많은 기능을 가진 HQL을 제공
    - 이는 별칭 없이도 사용가능
- TypeQuery, Query
    - 작성한 JPQL을 실행하려면 쿼리 객체를 만들어야
    - 쿼리 객체
        - 반환할 타입을 명확하게 지정할 수 있으면 TypeQuery
            - 타입을 변환할 필요가 없어서 더 편리
        - 반환 타입을 명확하게 지정할 수 없으면 Query 객체를
            - 조회 대상이 둘 이상이면 Object[ ]를 반환
            - 조회 대상이 하나면 Object를 반환
- 결과 조회
    - 실제 쿼리를 실행해서 데이터베이스를 조회하는 메소드
    - query.getResultList : 결과를 반환, 결과 없으면 빈 컬렉션을 반환
    - query.getSingleResult : 결과가 정확히 하나일 때 사용
        - 결과가 없으면 NoResultException 예외 발생
        - 1개보다 많으면 NonUniqueResultException 발생
- 파라미터 바인딩
    - JDBC는 위치 기준 파라미터만 지원
    - JPQL은 이름 기준 파라미터 바인딩도 지원
        - 파라미터를 이름으로 구분하는 방법
        - 앞에 ':'를 사용
        - 예) query.setParameter()에서 username이라는 이름으로 파라미터를 바인딩
    - 위치 기준 파라미터
        - '?' 다음에 위치 값을 주면 된다
        - 위치값은 1부터 시작
    - 이름 기준 파라미터 바인딩 방식이 더 명확
    - 파라미터 바인딩이 아닌 직접 문자를 더해 만들어 넣으면
        - 악의적 사용자로 인해 SQL 인젝션 공격을 당할 수 있다
    - 파라미터 값이 달라도 재사용 가능
    - 데이터베이스 내부에서 실행한 SQL을 파싱해서 사용하는데 같은 쿼리는 파싱한 결과를 재사용할 수 있다. (무슨말?)
    - 애플리케이션과 데이터베이스 모두 해당 쿼리의 파싱 결과를 재사용할 수 있다
        - 전체 성능이 향상된다.
        - **파라미터 바인딩 방식은 선택이 아닌 필수**
- 프로젝션
    - select 절에 조회할 대상을 지정하는 것
    - select 프로젝션 대상 from
    - 프로젝션 대상
        - 엔티티 프로젝션
            - 원하는 객체를 바로 조회
            - 조회한 엔티티는 영속성 컨텍스트에서 관리
        - 임베디드 타입 프로젝션
            - 조회의 시작점이 될 수 없다는 제약
            - 임베디드 타입은 엔티티 타입이 아닌 값타입
            - 이렇게 직접 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않는다
        - 스칼라 타입 프로젝션
            - 숫자, 문자, 날짜와 같은 기본 데이터 타입들
            - 통계 쿼리
        - 여러 값 조회
            - 꼭 필요한 데이터들만 선택해서 조회
            - TypeQuery 사용 불가. 오직 Query
            - 조회한 엔티티는 영속성 컨텍스트에서 관리
        - NEW 명령어
            - 두 필드를 프로젝션해서 타입을 지정할 수 없다 → TypeQuery 사용 불가
            - Object[ ]를 직접 사용하지 않고 UserDTO처럼 의미있는 객체로 변환해서 사용
            - NEW 명령어 사용시 반환받을 클래스를 지정할 수 있다
            - 이 클래스의 생성자에 JPQL 조회 결과를 넘겨줄 수 있다
            - NEW 명령어를 사용한 클래스로 TypeQuery를 사용할 수 있어 지루한 객체 변환 작업을 줄일 수 있다.
            1. 패키지명을 포함한 전체 클래스명을 입력해야
            2. 순서와 타입이 일치하는 생성자가 필요
- 페이징 API
    - 페이징 처리용 쿼리 작성 : 지루 + 반복적
    - 데이터베이스마다 페이징을 처리하는 쿼리 문법이 다르다
    - JPA는 페이징을 다음 API로 추상화
        - setFirstResult : 조회 시작 위치 (0부터 시작)
        - setMaxResult : 조회할 데이터 수
    - 데이터베이스 방언에 따라 적절한 쿼리로 변환
    - 좀 더 최적화 : 네이티브 SQL
- 집합과 정렬
    - 집합 : 집합함수와 함께 통계 정보를 구할 때 사용
    - COUNT, MAX, MIN, AVG, SUM
    - 참고사항
        - NULL 값은 무시하므로 통계에 잡히지 않는다. (distinct가 정의되어 있어도 무시)
        - 만약 값이 없는데 MAX, MIN, AVG, SUM gkatn tkdyd - null 값이 된다
            - count는 0
        - distinct를 집합 함수 안에 사용해서 중복값을 제거하고 나서 집합을 구할 수 있다
        - distinct를 count에서 사용할 때 임베디드 타입은 지원하지 않는다
    - GROUP BY, HAVING
        - group by : 통계 데이터를 구할 때 특정 그룹끼리 묶어준다
        - having : group by와 함께 사용. 그룹화된 통계 데이터를 기준으로 필터링
        - 리포팅 쿼리, 통계 쿼리
            - 보통 전체 뎅이터를 기준으로 처리. 실시간으로 사용하기엔 부담
    - 정렬, order by
        - asc(기본값), desc
- JPQL 조인
    - 쿼리 조인과 기능은 같고 문법만 약간 다르다
    - 내부 조인
        - inner join. inne는 생략 가능
        - JPQL 조인의 가장 큰 특징 : 연관 필드를 사용한다는 것
        - ex) from Member m join m.team t
        - 서로 다른 타입의 두 엔티티를 조회했으므로 TypeQuery를 사용할 수 없다
    - 외부 조인
        - SQL의 외부 조인과 기능적으로 같다
        - outer는 생략 가능 - 보통 LEFT JOIN으로 사용
    - 컬렉션 조인
        - 일대다 혹은 다대다 관계처럼 컬렉션을 사용하는 곳에 조인하는 것
        - 다대일 조인 : 단일 값 연관필드를 사용, m.team
        - 일대다 조인 : 컬렉션 값 연관필드를 사용, m.members
        - 컬렉션 조인 시, join 대신에 in을 사용할 수 있다. 걍 join 쓰자
    - 세타 조인
        - where절을 사용해서 세타조인 할 수 있다
        - 내부 조인만 지원
        - 전혀 관계없는 엔티티도 조인 가능
    - JOIN ON 절 (JPA 2.1)
        - 조인 대상을 필터링하고 조인할 수 있다
        - 내부조인의 on 절은 where 절을 사용할 때와 결과가 같아지므로
        - 보통 on 절은 외부조인에서만 사용
- 페치 조인
    - SQL에서 이야기하는 조인의 종류는 아님
        - JPQL에서 성능 최적화를 위해 제공하는 기능
        - 연고나된 엔티티나 컬렉션을 한번에 같이 조회하는 기능
        - join jetch 명령어로 사용
    - 엔티티 페치 조인
        - 페치 조인을 사용해서 회원 엔티티를 조회하면서 연관된 팀 엔티티도 함께 조회하는 JPQL
        - join fetch : 연관된 엔티티나 컬렉션을 함께 조회
        - 페치 조인은 별칭을 사용할 수 없다
            - 하이버네이트에서는 사용 가능
        - 회원 엔티티만 선택해도 팀 엔티티를 조회할 수 있다
        - 회원과 팀 객체가 객체 그래프를 유지하면서 조회되었다
        - 회원과 팀을 지연로딩으로 설정했다는 가정하에서...
            - 회원을 조회할 때 페치 조인을 사용해서 팀도 함께 조회
            - 여놘된 팀 엔티티는 프록시가 아닌 실제 엔티티
            - 연관된 팀을 사용해도 지연 로딩이 일어나지 않는다
            - 프록시가 아닌 실제 엔티티라서 영속성 컨텍스트에서 분리되어 준영속 상태가 되어도 연관된 팀을 조회할 수 있다
    - 컬렉션 페치 조인
        - 예) 일대다 관계인 컬렉션을 페치 조인
            - 연관된 회원 컬렉션도 함께 조회됨
        - 조인하면서 결과가 증가
            - 일쪽 값에서 동일한 값으로 2개 이상의 결과가 나타날 수 있다
        - 일대다 조인은 결과가 증가할 수 있지만
            - 일대일, 다대일 조인은 결과가 증가하지 않는다.
    - 페치 조인과 distinct
        - 중복된 결과를 제거하는 명령어
        - JPQL의 distinct 명령어는
            - SQL에 distinct를 추가하는 것은 물론
            - 애플리케이션에서 한번 더 중복을 제거
        - SQL의 경우
            - 직전 컬렉션 페치 조인 사례에 적용했을 때는 효과가 없음
            - 각 데이터가 다르기 때문
        - 애플리케이션의 경우
            - 컬렉션 페치 조인에서는 팀 조회 결과가 2번 출력
            - 하지만 이 경우에서는 1회만 출력. 중복이 제거됨.
    - 페치 조인과 일반 조인의 차이
        - 페치 조인을 사용하지 않고 일반 조인만 사용하면 지정한 대상만 조회된다.
            - 다른 엔티티와 컬렉션이 조회되는 것을 기대해선 안된다.
        - JPQL은 결과를 반환할 때
            - 연관관계를 고려하지 않는다
            - 단지 select 절에 지정한 엔티티만 조회할 뿐
        - 만약 회원 컬렉션을 지연 로딩으로 설정하면
            - 프록시나 아직 초기화하지 않은 컬렉션 래퍼를 반환
        - 즉시 로딩으로 설정하면
            - 회원 컬렉션을 즉시 로딩하기 위해 쿼리를 한 번 더 실행
        - 페치 조인을 사용하면
            - 연관된 엔티티도 함께 조회. 단 1번의 쿼리로 해결
    - 페치 조인의 특징과 한계
        - SQL 호출 횟수를 줄여 성능을 최적화할 수 있다
        - 글로벌 로딩 전략
            - 엔티티에 직접 적용하는 로딩 전략
            - 애플리케이션 전체에 영향을 미치므로
        - 페치 조인은 글로벌 로딩 전략보다 우선한다
            - 글로벌 로딩 전략을 지연 로딩으로 설정해도
            - JPQL에서 페치 조인을 사용하면 페치 조인을 적용해서 함께 조회
        - 최적화를 위해 글로벌 로딩 전략을 즉시 로딩으로 설정하면
            - 애플리케이션 전체에서 항상 즉시 로딩이 일어난다
            - 일부는 빠를 수 있지만 전체를 보면 사용하지 않는 엔티티를 자주 로딩하므로
            - 오히려 성능에 악영향
            - **글로벌 로딩 전략은 지연 로딩을 사용하고**
            - **최적화가 필요하면 페치 조인을 적용하는 것이 효과적**
        - 페치 조인을 사용하면 연관된 엔티티를 쿼리 시점에 조회
            - 지연 로딩이 발생하지 않는다
            - 따라서 준영속 상태에서도 객체 그래프를 탐색할 수 있다
        - 한계 1. 페치 조인 대상에는 별칭을 줄 수 없다
            - select, where, 서브쿼리에 페치 조인 대상을 사용할 수 없다
            - 별칭을 잘못 사용하면 연관된 데이터 수가 달라져서 데이터 무결성이 깨질 수도
            - 2차 캐시와 함께 사용시 특히 주의 : 연관된 데이터 수가 달라지는 문제가 발생 (16장에서 자세히)
        - 한계 2. 둘 이상의 컬렉션을 페치할 수 없다
            - 카테시안 곱(컬렉션 x 컬렉션)에 주의
        - 한계 3. 컬렉션을 페치하면 페이징 API를 사용할 수 없다
            - 컬렉션(일대다)이 아닌 단일 값 연관 필드(일대일, 다대일)들은 페치 조인을 사용해도 페이징 API 사용 가능
            - 하이버네이트는 컬렉션도 가능. 다만 성능 이슈와 메모리 초과 예외가 발생할 수 있다
    - 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적
        - 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 한다면
        - 페치 조인보다는 여러 테이블에서 필요한 필드만 조회해서 DTO로 반환하는 것이 효과적일 수 있다
- 경로 표현식
    - 점을 찍어 객체 그래프를 탐색하는 것
        - m.username, m.team, t.name
    - 경로 표현식의 용어 정리
        - 상태 필드 : 단순히 값을 저장하기 위한 필드 (필드, 프로퍼티, t.username)
        - 연관 필드 : 연관관계를 위한 필드, 임베디드 타입 포함 (필드, 프로퍼티)
            - 단일 값 연관 필드 : ManyToOne, OneToOne, 대상이 엔티티
                - m.team
            - 컬렉션 값 연관 필드 : OneToMany, ManyToOne, 대상이 컬렉션
                - m.orders
    - 특징
        - 경로 탐색을 하려면 3가지 경로에 따라 어떤 특징이 있는지 이해해야
        - 상태 필드 경로
            - 경로 탐색의 끝. 더는 탐색 못함
        - 단일 값 연관 경로
            - 묵시적으로 내부조인이 일어난다
                - 묵시적 조인 : 단일 값 연관필드로 경로 탐색을 하면 쿼리에서 내부 조인이 일어남
                - 묵시적 조인은 무조건 내부 조인
                - 외부 조인은 명시적으로 join 키워드를 사용해야
            - 단일 값 연관 경로는 계속 탐색할 수 있다
            - 예) o.address처럼 임베디드 타입에 접근하는 것도 단일 값 연관 경로 탐색이지만
                - 주문 테이블에 이미 포함되어 있으므로 조인이 발생하지 않음
        - 컬렉션 값 연관 경로
            - 묵시적으로 내부조인이 일어난다 : 묵시적 조인
            - 더는 탐색 불가
            - 단 from 절에서 조인을 통해 별칭을 얻으면 별칭으로 탐색 가능
            - 컬렉션에서 경로 탐색을 시작하는 것은 허락하지 않음
                - 하고 싶다면 조인을 사용해서 새로운 별칭을 획득해야
            - 컬렉션의 크기를 구할 수 있는 size 기능
                - count 함수를 사용하는 SQL로 적절히 변환
    - 경로 탐색을 사용한 묵시적 조인시 주의사항
        - 항상 내부 조인
        - 컬렉션은 경로 탐색의 끝. 경로탐색하고 싶다면 명시적으로 조인해서 별칭을 얻어야
        - 경로 탐색은 주로 select, where절에서 사용하지만 묵시적 조인으로 인해 SQL의 from 절에 영향을 준다
        - 단점 : 묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어렵다
            - 성능이 중요하면 분석하기 쉽도록 묵시적 조인보다는 명시적 조인을 사용하자
- 서브 쿼리
    - where, having 절에서만 사용 가능
        - select, from 절에서는 불가능
        - 하이버네이트는 select도 가능
        - 사견 : 이정도면 차별화가 아니라 집착과 견제인듯
    - 서브쿼리에서 컬렉션 값 연관 필드의 size 기능 사용 가능
    - 서브쿼리 함수
        - EXISTS : 서브쿼리에 결과가 존재하면 참
        - ALL, ANY, SOME : 비교연산자와 함께 사용
            - 모두 만족, 하나라도 만족
        - IN : 하나라도 같은 것이 있으면
- 조건식
    - 타입 표현
        - 문자, 숫자, 날짜, Boolean, enum
        - 그리고 엔티티 타입
            - 주로 상속과 관련해서 사용
            - TYPE(m) = Member
        - 대소문자는 구분 안함
    - 연산자 우선 순위
        1. 경로 탐색 연산 : .(점)
        2. 수학 연산 : 단항연산자
        3. 비교 연산
        4. 논리 연산 : not, and, or
    - 논리 연산과 비교식
        - 논리연산 : and, or, not
        - 비교식 : 등호와 부등호
    - Between, IN, Like, NULL
        - Between : a ~ b 사이의 값인가 (a, b 포함)
        - IN : 하나라도 있으면 참
        - Like : 문자 표현식과 패턴값을 비교
        - %(퍼센트) , _(언더라인)
        - NULL : null인지 비교 =(equal)로 비교 불가
    - 컬렉션 식
        - 컬렉션에서만 사용하는 기능. 이것 외 다른 식은 사용 불가
        - 빈 컬렉션 비교식
            - is {not} empty
            - is null 불가
        - 멤버 식
            - 엔티티나 값이 컬렉션에 포함되어 있으면 참
            - {not} 엔티티 {of}
    - 스칼라 식
        - 가장 기본적인 타입
        - 수학식, 문자함수, 수학함수, 날짜함수
    - CASE 식
        - 특정 조건에 따라 분기할 때
        - 기본, 심플(조건식이 없음), COALESCE(null이 아니면 반환), NULLIF(두 값 같으면 null, 다르면 첫번째 값)
- 다형성 쿼리
    - JPQL로 부모 엔티티를 조회하면 그 자식 엔티티도 함께 조회
    - TYPE : 엔티티의 상속 구조에서 조회 대상을 특정 자식 타입으로 한정할 때 주로 사용
    - THEAT(JPA 2.1) : 자바의 타입 캐스팅과 유사. 부모 타입을 특정 자식 타입으로 다룰 때
- 사용자 정의 함수 호출 (JPA 2.1)
    - 하이버네이트 같은 구현체를 사용하면 방언 클래스를 상속해서 구현하고
    - 사용할 데이터베이스 함수를 미리 등록해야 한다
- 기타 정리
    - enum은 = 비교 연산만 지원
    - 임베디드 타입은 비교를 지원하지 않는다
    - empty string과 null (데이터베이스에 따라)
    - null
        - 조건을 만족하는 데이터가 없으면 null
        - 알수 없는 값
- 엔티티 직접 사용
    - 기본키 값
    - 외래키 값 : 묵시적 조인이 일어나지 않는다
- Named 쿼리
    - 동적 쿼리 : JPQL을 문자로 완성해서 직접 넘기는 것
        - 런타임에 특정조건에 따라 JPQL을 동적으로 구성
    - 정적 쿼리 : 미리 정의한 쿼리에 이름을 부여해서 필요할 때 사용하라 수 있다
        - Named 쿼리 - 한번 정의하면 변경불가(정적)
        - 애플리케이션 로딩시점에 JPQL 문법을 체크하고 미리 파싱
        - 오류를 빨리 확인, 파싱된 결과를 재사용 - 성능적 이점
        - 정적 SQL이 생성되므로 데이터베이스의 조회 성능 최적화에도 도움
- Named 쿼리를 어노테이션에 정의
    - @NamedQuery
    - name 속성
        - 기능적 특별한 의미 없음
        - Named 쿼리는 영속성 유닛 단위로 관리 - 충돌방지하기 위해 엔티티 이름을 앞에 주고 있다
    - 2개 이상의 쿼리 : @NamedQueries
- Named 쿼리를 XML에 정의
    - 어노테이션으로 작성할 수 있는 것은 xml로도 작성 가능
        - 어노테이션을 사용하는 것이 더 직관적이고 편리
    - 하지만 Named 쿼리는 xml이 더 편하다
        - 자바 언어로 멀티라인 문자를 다루는 것은 귀찮다
        - 그 대안이 xml
        - 예약 문자 (사견: 이게 더 귀찮을 수도)
        - orm.xml : JPA가 기본 매핑파일로 인식
            - 이름이나 위치가 변경되면 별도 처리해야. persistence.xml
- 환경에 따른 설정
    - 어노테이션과 xml 중에는 xml이 우선권을 가짐
    - 애플리케이션이 운영 환경에 따라 다른 쿼리를 실행해야 한다면
        - 각 환경에 맞춘 xml을 준비하고 xml만 변경해서 배포
