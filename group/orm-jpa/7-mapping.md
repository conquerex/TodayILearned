# 7장. 고급 매핑

## 입구

* 자... 드가자..


## 1. 상속 관계 매핑

* 관계형 데이터베이스 : 객체지향 언어에서 다루는 상속이라는 개념 없음
* 그 대신... 슈퍼타입 서브 타입 관계 (Super-Type Sub-Type Relationship)
* ORM에서 이야기하는 상속 관계 매핑
  * 객체의 상속 구조와 데이터베이스의 슈퍼타입 서브타입 관계를 매핑하는 것

* 슈퍼타입 서브타입 논리 모델을 실제 물리 모델인 테이블로 구현할 때
  * 3가지 방법
  * 조인 전략, 단일 테이블 전략, 구현 클래스마다 테이블 전략


* 조인 전략
  * 각각의 테이블로 변환
  * 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본키를 받아서
  * 기본키 + 외래키로 사용하는 전략
  * 주의점 : 객체는 타입으로 구분가능, 테이블은 아님
    * 타입을 구분하는 컬럼 (ex. DTYPE 컬럼을 구분 컬럼으로 사용)
  * @Inheritance(strategy = InheritanceType.JOINED)
    * 상속매핑은 부모클래스에 본 어노테이션 사용
    * strategy 속성 : 지정한 매핑 전략 - 여기서는 조인 전략
  * @DiscriminatorColum(name = "DTYPE")
    * 부모 클래스에 구분 컬럼을 지정
    * 저장된 자식 테이블을 구분할 수
    * 기본값이 DTYPE이므로 name 속성없이 사용 가능
  * @DiscriminatorValue("M")
    * 엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정
    * 영화 엔티티를 저장 : DTYPE에 "M"
    * 앨범 엔티티를 저장 : DTYPE에 "A"
  * 기본적으로 자식테이블은 부모테이블의 ID 컬럼명을 그대로 사용
    * 변경하고 싶다면 @PrimaryKeyJoinColumn 사용
  * 장점
    * 테이블이 정규화된다
    * 외래키 참조 무결성 제약조건을 활용할 수 있다
    * 저장공간을 효율적으로 사용한다
  * 단점
    * 조회활 때 조인이 많이 사용 - 성능이 저하될 수
    * 조회 쿼리가 복잡
    * 데이터를 등록할 insert SQL을 두번 실행
  * 특징
    * JPA 표준 명세는 구분 컬럼을 사용하도록 하지만
    * 하이버네이트를 포함한 몇몇 구현체는 구분컬럼 없이도 동작한(DiscriminatorColum)

* 단일 테이블 전략
  * 통합 테이블로 변환
  * 테이블 하나만 사용
  * 구분 컬럼으로 어떤 자식 데이터가 저장되었는지 구분
  * 조인 사용하지 않고 가장 빠름
  * 주의점 : 자식 엔티티가 매핑한 컬럼은 모두 null 허용
    * 책 엔티티에는 앨범 정보와 관련된 컬럼을 null로
  * @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
  * 장점
    * 조인이 필요없음 - 일반적으로 조회 성능이 가장 빠름
    * 조회 쿼리가 단순
  * 단점
    * 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야
    * 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수도
      * 상황에 따라서는 조회 성능이 오히려 느려질 수 있다
  * 특징
    * 구분 컬럼을 꼭 사용해야 한다
      * @DiscriminatorColum을 꼭 설정해야
    * @DiscriminatorValue를 지정하지 않으면 기본으로 엔티티 이름을 사용
      * ex. Movie, Album, Book

* 구현 클래스마다 테이블 전략 (Table-per-Concrete-Class Strategy)
  * 서브타입 테이블로 변환
  * 자식 엔티티마다 테이블을 만든다
  * 자식 테이블 각각에 필요한 컬럼이 모두 있다
  * @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
  * 일반적으로 <mark style="color:red;">**추천하지 않는 전략**</mark>
  * 장점
    * 서브 타입을 구분해서 처리할 때 효과적
    * not null 제약 조건을 사요할 수 있다
  * 단점
    * 여러 자식 테이블을 함께 조회할 때 성능이 느리다 (SQL에서 union 사용해야)
    * 자식 테이블을 통합해서 쿼리하기 어렵다
  * 특징
    * 구분 컬럼을 사용하지 않는다



## 2. @MappedSuperclass

* 만약 부모클래스는 테이블과 매핑하지 않고
* 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공하고 싶다면
* 짜잔~~ @MappedSuperclass
  * 비유하자면 추상 클래스와 비슷
  * @Entity는 실제 테이블과 매핑, but @MappedSuperclass는 아니다
  * BaseEntity : 객체들이 주로 사용하는 공통 매핑 정보를 정의
* @AttributeOverrides, @AttributeOverride
  * 부모로부터 물려받은 매핑 정보를 재정의
* @AssociationOverrides, @AssociationOverrides
  * 연관관계를 재정의
* 사용 예시 : 등록일자, 수정일자, 등록자, 수정자 등
* 참고 : 엔티티는 엔티티이거나 MappedSuperclass로 지정한 클래스만 상속받을 수 있다



## 3. 복합키와 식별 관계 매핑

* 식별 관계
  * 부모테이블의 기본키를 내려받아서 자식 테이블의 기본 + 외래키를 사용하는 관계
* 비식별 관계
  * 부모테이블의 기본키를 받아서 자식테이블의 외래키로만 사용하는 관계
  * 필수적 비식별 관계 (Mandatory)
    * 외래키에 null 허용 안함. 연관관계를 필수적으로 맺어야
  * 선택적 비식별 관계 (Optional)
   * 외래키에 null 허용. 연관관계를 선택적으로
* 비식별을 주로 사용, 필요한 곳에만 식별관계를 사용하는 추세
  * JPA는 둘 모두 지원

* 복합키 : 비식별 관계 매핑
  * JPA에서 식별자를 둘 이상 사용하려면 별도의 식별자 클래스를 만들어야
  * JPA는 영속성 컨텍스트에 엔티티를 보관할 때
    * 엔티티의 식별자를 키로 사용
  * 식별자 구분 위해 equals, hashCode를 사용해서 동등성 비교
  * 식별자 하나일때는 자바의 기본타입을 사용
    * 식별자 필드 2개 이상 : 별도의 식별자 클래스 만들고 별도의 equals, hashCode를 구현해야
  * JPA는 복합키를 지원하기 위해 @IdClass, @EmbeddidId를 제공
    * 공통된 특징
      * Serializable 인터페이스를 구현해야
      * equals, hashCode를 구현해야
      * 기본 생성자가 있어야
      * 식별자 클래스는 public
  * @IdClass
    * 관계형 데이터베이스에 가까운 방법
    * 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야
  * @EmbeddidId
    * 객체지향에 가까운 방법
    * EmbeddidId를 적용한 식별자 클래스는 식별자 클래스에 기본키를 직접 매핑
    * EmbeddidId 어노테이션을 붙여주어야
  * 복합키와 equals(), hashCode()
    * 자바의 모든 클래스는 기본으로 Object 클래스를 상속받는데
    * 이 클래스가 제공하는 기본 equals(), hashCode()는 인스턴스 참조값 비교인 == 비교를 함(동일성 비교)
    * 영속성 컨텍스트는 엔티티의 식별자를 키로 사용해서 엔티티를 관리
      * 식별자 객체의 동등성(equals)이 지켜지지 않으면 예상과 다른 엔티티가 조회되거나 찾을 수 없는 등의 이슈가 발생
      * 영속성 컨텍스트는 엔티티 관리에 심각한 문제가 발생
  * @EmbeddidId가 @IdClass와 비교해서 더 객체지향적이고 중복도 없다
    * but 특정상황에서 JPQL이 조금 더 길어질 수
  * 복합키에는 @GenerateValue를 사용할 수 없다. 복합키를 구성하는 여러 컬럼 중 하나에도 사용할 수 없다

* 복합키 : 식별 관계 매핑
  * 자식 테이블은 부모테이블의 기본키를 포함해서 복합키를 구성
  * @IdClass와 식별관계
    * 식별자 매핑인 @Id와 연관관계 매핑인 @ManyToOne을 같이 사용
    * 예) Child 엔티티의 parent 필드
  * @EmbeddidId가 식별관계
    * 식별관계로 사용할 연관고나계의 속성에 @MapsId를 사용하면 된다
    * MapsId : 외래키와 매핑한 연관관계를 기본키에도 매핑하겠다는 뜻
      * 속성값은 EmbeddidId를 사용한 식별자 클래스의 기본키 필드를 지정하면 됨
      * 예) ChildId의 parentId 필드

* 비식별 관계로 구현
  * 매핑도 쉽고 코드도 단순
  * 복합키 클래스르 만들지 않아도 됨

* 일대일 식별 관계
  * 자식 테이블의 기본키값으로 부모테이블의 기본키 값만 사용
  * 부모테이블의 기본키가 복합키가 아니라는 가정
  * @MapsId를 사용하고 속성값은 비워두면 됨


* 데이터베이스 설계 관점에서 보면 식별보다 비식별을 선호
  * 식별은 부모테이블의 기본키를 자식으로 전파하면서 자식의 기본키 컬럼이 점점 늘어난다
    * 결국 조인할 때 SQL이 복잡, 기본키 인덱스가 불필요하게 커질 수
  * 식별은 2개이상의 컬럼을 합해서 복합 기본키를 만들어야 하는 경우가 많다
  * 식별을 상요할 때 기본키로 비즈니스 의미가 있는 자연키 컬럼을 조합하는 경우가 많다
    * 반면 비식별은 비즈니스와 관계없는 대리키를 주로 사용
    * 비즈니스 요구사항은 언젠가 변함
    * 식별의 자연키 컬럼들이 자식에 손자까지 전파되면 변경이 어렵다
  * 식별은 부모테이블의 기본키를 자식의 기본키로 사용
    * 비식별 고나계보다 테이블 구조가 유연하지 못하다

* 객체 관계 매핑 관점에서 보면 비식별 선호
  * 일대일 관계를 제외. 식별은 2개 이상의 컬럼을 묶은 복합키를 사용
    * JPA에서 복합키 : 별도의 복합키 클래스를 만들어야
    * 따라서 컬럼이 하나인 기본키를 매핑하는 것보다 많은 노력이
  * 비식별 관계의 기본키는 주로 대리키 사용
    * JPA는 GenerateValue처럼 대리키를 생성하기 위한 편리한 방법을 제공

* 식별이 가지는 장점
  * 기본키 인덱스를 활용하기 좋고
  * 상위 테이블들의 기본키 컬럼을 자식, 손자 테이블들이 가지고 있으므로
  * 특정 상황에 조인없이 하위 테이블 만으로 검색을 완료 가능

* ORM 신규 프로젝트 진행시 추천 방법
  * 비식별 고나계를 사용, 기본키는 (Integer보다는) Long 타입의 대리키
  * 대리키는 비즈니스와 관계없다.
  * (사견) 계정 정보 정도를 제외하고는 대부분 이렇게 사용
  * 필수적 비식별이 좋은 이유
    * 선택적 비식별 : null을 허용. 조인할때에 외부 조인을 사용해야 한다
    * not null을 보장하면 항상 관계가 있다는 것을 보장하므로 내부 조인만 사용해도 됨



## 4. 조인 테이블

* 데이터베이스 테이블의 연관관계를 설계하는 방법
  * 조인 컬럼 사용 - 외래키
    * 테이블 간에 관계느 ㄴ주로 조인컬럼이라 부르는 외래키 컬럼을 사용
    * 외래키에 null을 허용 - 선택적 비식별 관계
    * 외부 조인을 사용해야
    * 아주 가끔 관계를 맺으면 - 대부분 외래키 값이 null (오우야 낭비)
  * 조인 테이블 사용 - 테이블 사용
    * 별도의 테이블을 사용해서 연관관계를 관리
    * 조인 테이블 : 두 테이블의 외래키를 가지고 연관관계를 관리
    * 단점 : 결국 테이블 추가
  * 객체와 테이블을 매핑할 때
    * 조인 컬럼은 @JoinColumn으로 매핑하고
    * 조인 테이블은 @JoinTable로 매핑
  * 조인 테이블은 주로 다대다 관계를 일대다, 다대일 관계로 풀어내기 위해 사용
    * 그렇지만 일대일, 일대다, 다대일 관계에서도 사용
  * 조인 테이블 == 연결 테이블, 링크 테이블
  * 일대일 조인 테이블
  * 일대다 조인 테이블
  * 다대일 조인 테이블
  * 다대다 조인 테이블


## 5. 엔티티 하나에 여러 테이블 매핑
