# 10장. 객체지향 쿼리 언어

## 입구

- JPA는 복잡한 검색 조건을 사용해서 엔티티 객체를 조회할 수 있는 다양한 쿼리 기술을 지원
- JPQL은 가장 중요한 객체지향 쿼리 언어
    - Criteria, QueryDSL은 결국 JPQL을 편리하게 사용하도록 도와주는 기술

## 1. 객체지향 쿼리 소개

- 가장 단순한 검색 방법
    - 식별자로 조회
        - EntityManager.find()
        - 이 메소드를 사용하면 식별자로 엔티티 하나를 조회할 수 있다
    - 객체 그래프 탐색
        - 예) a.getB()
        - 연관된 엔티티들을 찾을 수 있다
- ORM을 사용하면 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 개발하므로
    - 검색도 테이블이 아닌 엔티티 객체를 대상으로 하는 방법이 필요
- JPQL의 특징
    - 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리
    - SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다
- SQL이 데이터베이스 테이블을 대상으로 하는 데이터 중심의 쿼리라면
    - JPQL은 엔티티 객체를 대상으로 하는 **객체지향 쿼리**
- JPQL을 사용하면
    - JPA는 이 JPQL을 분석한 다음 적절한 SQL을 만들어 데이터베이스를 조회
    - 그리고 조회한 결과로 엔티티 객체를 생성해서 반환
- JPA가 공식 지원하는 기능
    - JPQL : Java Persistence Query Language
    - Criteria Query : JPQL을 편하게 작성하도록 도와주는 API, 빌더 클래스 모음
    - 네이티브 Query : JPA에서 JPQL 대신 직접 SQL을 사용할 수 있다
- JPA가 공식 지원하는 기능은 아니지만...
    - QueryDSL
        - 크리테리아 쿼리처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스 모음
        - 비표준 오픈소스 프레임워크
    - JDBC 직접 사용, MyBatis 같은 SQL 매퍼 프레임워크 사용
        - 필요하면 JDBC를 직접 사용할 수 있다
- JPQL
    - 엔티티 객체를 조회하는 객체지향 쿼리
    - 문법은 SQL과 유사
    - SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다
    - 데이터베이스 방언만 변경하면 JPQL을 수정하지 않아도 자연스럽게 데이터베이스를 변경할 수 있다.
    - SQL보다 간결하다
        - 엔티티 직접 조회, 묵시적 조인, 다형성 지원으로 간결
- 예) delect m from Member as m where m.username = 'kim'
    - m.username : 테이블 컬럼명이 아닌 엔티티 객체의 필드명
    - em.createQuery 메소드를 실행할 JPQL과
    - 반환할 엔티티의 클래스 타입인 Member.class를 넘겨주고
    - getResultList 메소드를 실행
    - JPA는 JPQL을 SQL로 변환해서 데이터베이스를 조회
    - 결과 : Member 엔티티를 생성해서 반환
- Criteria 쿼리
    - JPQL을 생성하는 빌더 클래스
    - 장점 : 문자가 아닌 query.select(m).where(...)처럼 프로그래밍 코드로 JPQL을 작성할 수 있다는 점
    - JPQL에서 오타가 있어도 컴파일은 성공하고 서버에 배포도 가능
        - 쿼리가 실행되는 런타임 시점에 오류가 발생
        - 문자 기반 쿼리의 단점
    - 그 외...
        - 컴파일 시점에 오류를 발견할 수 있다
        - IDE를 사용하면 코드 자동완성을 지원
        - 동적 쿼리를 작성하기 편하다
    - 몇몇 ORM 프레임워크들이 오래전부터 자신만의 크리테리아 지원
        - JPA 2.0부터
    - 필드명을 문자로 작성  → 해결 : 메타 모델
    - 단점
        - 모든 장점을 상쇄할 정도로 복잡 + 장황
        - 사용하기 불편, 작성한 코드도 한눈에 들어오지 않음
- QueryDSL
    - 크리테리아처럼 JPQL 빌더 역할
    - 장점
        - 코드 기반이면서 단순하고 사용하기 쉽다
        - 작성한 코드도 JPQL과 비슷해서 한눈에 들어온다
    - JPA 표준이 아님
        - 오픈소스 프로젝트
        - JDO, 몽고DB, Java Collection, Lucene, Hibernate Search도 거의 같은 문법으로 지원
        - 현재 스프링 데이터 프로젝트가 지원할 정도로 많이 기대되는 프로젝트
    - 어노테이션 프로세서를 사용해서 쿼리 전용 클래스를 만들어야 한다
- 네이티브 SQL
    - JPA는 SQL을 직접 사용할 수 있는 기능을 지원
    - 가끔 특정 데이터베이스에 의존하는 기능을 사용해야 할 때
    - SQL은 지원하지만 JPQL이 지원하지 않는 기능일 때
    - 단점
        - 특정 데이터베이스에 의존하는 SQL을 작성해야 한다는 것
        - 데이터베이스를 변경하면 네이티브 SQL도 수정해야
    - em.createNativeQuery()
- JDBC 직접 사용, 마이바티스같은 SQL 매퍼 프레임워크 사용
    - JPA는 JDBC 커넥션을 획득하는 API를 제공하지 않음
        - JPA 구현체가 제공하는 방법을 사용해야
    - JDBC나 마이바티스를 JPA와 함께 사용하면
        - 영속성 컨텍스트를 적절한 시점에 강제로 플러시해야 한다
